// Code generated by counterfeiter. DO NOT EDIT.
package controllerfakes

import (
	"sync"
	"time"

	"github.com/alext/heating-controller/controller"
	"github.com/alext/heating-controller/units"
)

type FakeEventHandler struct {
	AddEventStub        func(controller.Event) error
	addEventMutex       sync.RWMutex
	addEventArgsForCall []struct {
		arg1 controller.Event
	}
	addEventReturns struct {
		result1 error
	}
	addEventReturnsOnCall map[int]struct {
		result1 error
	}
	BoostStub        func(time.Duration)
	boostMutex       sync.RWMutex
	boostArgsForCall []struct {
		arg1 time.Duration
	}
	BoostedStub        func() bool
	boostedMutex       sync.RWMutex
	boostedArgsForCall []struct {
	}
	boostedReturns struct {
		result1 bool
	}
	boostedReturnsOnCall map[int]struct {
		result1 bool
	}
	CancelBoostStub        func()
	cancelBoostMutex       sync.RWMutex
	cancelBoostArgsForCall []struct {
	}
	FindEventStub        func(units.TimeOfDay) (controller.Event, bool)
	findEventMutex       sync.RWMutex
	findEventArgsForCall []struct {
		arg1 units.TimeOfDay
	}
	findEventReturns struct {
		result1 controller.Event
		result2 bool
	}
	findEventReturnsOnCall map[int]struct {
		result1 controller.Event
		result2 bool
	}
	NextEventStub        func() *controller.Event
	nextEventMutex       sync.RWMutex
	nextEventArgsForCall []struct {
	}
	nextEventReturns struct {
		result1 *controller.Event
	}
	nextEventReturnsOnCall map[int]struct {
		result1 *controller.Event
	}
	ReadEventsStub        func() []controller.Event
	readEventsMutex       sync.RWMutex
	readEventsArgsForCall []struct {
	}
	readEventsReturns struct {
		result1 []controller.Event
	}
	readEventsReturnsOnCall map[int]struct {
		result1 []controller.Event
	}
	RemoveEventStub        func(units.TimeOfDay) error
	removeEventMutex       sync.RWMutex
	removeEventArgsForCall []struct {
		arg1 units.TimeOfDay
	}
	removeEventReturns struct {
		result1 error
	}
	removeEventReturnsOnCall map[int]struct {
		result1 error
	}
	ReplaceEventStub        func(units.TimeOfDay, controller.Event) error
	replaceEventMutex       sync.RWMutex
	replaceEventArgsForCall []struct {
		arg1 units.TimeOfDay
		arg2 controller.Event
	}
	replaceEventReturns struct {
		result1 error
	}
	replaceEventReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeEventHandler) AddEvent(arg1 controller.Event) error {
	fake.addEventMutex.Lock()
	ret, specificReturn := fake.addEventReturnsOnCall[len(fake.addEventArgsForCall)]
	fake.addEventArgsForCall = append(fake.addEventArgsForCall, struct {
		arg1 controller.Event
	}{arg1})
	stub := fake.AddEventStub
	fakeReturns := fake.addEventReturns
	fake.recordInvocation("AddEvent", []interface{}{arg1})
	fake.addEventMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeEventHandler) AddEventCallCount() int {
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	return len(fake.addEventArgsForCall)
}

func (fake *FakeEventHandler) AddEventCalls(stub func(controller.Event) error) {
	fake.addEventMutex.Lock()
	defer fake.addEventMutex.Unlock()
	fake.AddEventStub = stub
}

func (fake *FakeEventHandler) AddEventArgsForCall(i int) controller.Event {
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	argsForCall := fake.addEventArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventHandler) AddEventReturns(result1 error) {
	fake.addEventMutex.Lock()
	defer fake.addEventMutex.Unlock()
	fake.AddEventStub = nil
	fake.addEventReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventHandler) AddEventReturnsOnCall(i int, result1 error) {
	fake.addEventMutex.Lock()
	defer fake.addEventMutex.Unlock()
	fake.AddEventStub = nil
	if fake.addEventReturnsOnCall == nil {
		fake.addEventReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addEventReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventHandler) Boost(arg1 time.Duration) {
	fake.boostMutex.Lock()
	fake.boostArgsForCall = append(fake.boostArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	stub := fake.BoostStub
	fake.recordInvocation("Boost", []interface{}{arg1})
	fake.boostMutex.Unlock()
	if stub != nil {
		fake.BoostStub(arg1)
	}
}

func (fake *FakeEventHandler) BoostCallCount() int {
	fake.boostMutex.RLock()
	defer fake.boostMutex.RUnlock()
	return len(fake.boostArgsForCall)
}

func (fake *FakeEventHandler) BoostCalls(stub func(time.Duration)) {
	fake.boostMutex.Lock()
	defer fake.boostMutex.Unlock()
	fake.BoostStub = stub
}

func (fake *FakeEventHandler) BoostArgsForCall(i int) time.Duration {
	fake.boostMutex.RLock()
	defer fake.boostMutex.RUnlock()
	argsForCall := fake.boostArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventHandler) Boosted() bool {
	fake.boostedMutex.Lock()
	ret, specificReturn := fake.boostedReturnsOnCall[len(fake.boostedArgsForCall)]
	fake.boostedArgsForCall = append(fake.boostedArgsForCall, struct {
	}{})
	stub := fake.BoostedStub
	fakeReturns := fake.boostedReturns
	fake.recordInvocation("Boosted", []interface{}{})
	fake.boostedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeEventHandler) BoostedCallCount() int {
	fake.boostedMutex.RLock()
	defer fake.boostedMutex.RUnlock()
	return len(fake.boostedArgsForCall)
}

func (fake *FakeEventHandler) BoostedCalls(stub func() bool) {
	fake.boostedMutex.Lock()
	defer fake.boostedMutex.Unlock()
	fake.BoostedStub = stub
}

func (fake *FakeEventHandler) BoostedReturns(result1 bool) {
	fake.boostedMutex.Lock()
	defer fake.boostedMutex.Unlock()
	fake.BoostedStub = nil
	fake.boostedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeEventHandler) BoostedReturnsOnCall(i int, result1 bool) {
	fake.boostedMutex.Lock()
	defer fake.boostedMutex.Unlock()
	fake.BoostedStub = nil
	if fake.boostedReturnsOnCall == nil {
		fake.boostedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.boostedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeEventHandler) CancelBoost() {
	fake.cancelBoostMutex.Lock()
	fake.cancelBoostArgsForCall = append(fake.cancelBoostArgsForCall, struct {
	}{})
	stub := fake.CancelBoostStub
	fake.recordInvocation("CancelBoost", []interface{}{})
	fake.cancelBoostMutex.Unlock()
	if stub != nil {
		fake.CancelBoostStub()
	}
}

func (fake *FakeEventHandler) CancelBoostCallCount() int {
	fake.cancelBoostMutex.RLock()
	defer fake.cancelBoostMutex.RUnlock()
	return len(fake.cancelBoostArgsForCall)
}

func (fake *FakeEventHandler) CancelBoostCalls(stub func()) {
	fake.cancelBoostMutex.Lock()
	defer fake.cancelBoostMutex.Unlock()
	fake.CancelBoostStub = stub
}

func (fake *FakeEventHandler) FindEvent(arg1 units.TimeOfDay) (controller.Event, bool) {
	fake.findEventMutex.Lock()
	ret, specificReturn := fake.findEventReturnsOnCall[len(fake.findEventArgsForCall)]
	fake.findEventArgsForCall = append(fake.findEventArgsForCall, struct {
		arg1 units.TimeOfDay
	}{arg1})
	stub := fake.FindEventStub
	fakeReturns := fake.findEventReturns
	fake.recordInvocation("FindEvent", []interface{}{arg1})
	fake.findEventMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventHandler) FindEventCallCount() int {
	fake.findEventMutex.RLock()
	defer fake.findEventMutex.RUnlock()
	return len(fake.findEventArgsForCall)
}

func (fake *FakeEventHandler) FindEventCalls(stub func(units.TimeOfDay) (controller.Event, bool)) {
	fake.findEventMutex.Lock()
	defer fake.findEventMutex.Unlock()
	fake.FindEventStub = stub
}

func (fake *FakeEventHandler) FindEventArgsForCall(i int) units.TimeOfDay {
	fake.findEventMutex.RLock()
	defer fake.findEventMutex.RUnlock()
	argsForCall := fake.findEventArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventHandler) FindEventReturns(result1 controller.Event, result2 bool) {
	fake.findEventMutex.Lock()
	defer fake.findEventMutex.Unlock()
	fake.FindEventStub = nil
	fake.findEventReturns = struct {
		result1 controller.Event
		result2 bool
	}{result1, result2}
}

func (fake *FakeEventHandler) FindEventReturnsOnCall(i int, result1 controller.Event, result2 bool) {
	fake.findEventMutex.Lock()
	defer fake.findEventMutex.Unlock()
	fake.FindEventStub = nil
	if fake.findEventReturnsOnCall == nil {
		fake.findEventReturnsOnCall = make(map[int]struct {
			result1 controller.Event
			result2 bool
		})
	}
	fake.findEventReturnsOnCall[i] = struct {
		result1 controller.Event
		result2 bool
	}{result1, result2}
}

func (fake *FakeEventHandler) NextEvent() *controller.Event {
	fake.nextEventMutex.Lock()
	ret, specificReturn := fake.nextEventReturnsOnCall[len(fake.nextEventArgsForCall)]
	fake.nextEventArgsForCall = append(fake.nextEventArgsForCall, struct {
	}{})
	stub := fake.NextEventStub
	fakeReturns := fake.nextEventReturns
	fake.recordInvocation("NextEvent", []interface{}{})
	fake.nextEventMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeEventHandler) NextEventCallCount() int {
	fake.nextEventMutex.RLock()
	defer fake.nextEventMutex.RUnlock()
	return len(fake.nextEventArgsForCall)
}

func (fake *FakeEventHandler) NextEventCalls(stub func() *controller.Event) {
	fake.nextEventMutex.Lock()
	defer fake.nextEventMutex.Unlock()
	fake.NextEventStub = stub
}

func (fake *FakeEventHandler) NextEventReturns(result1 *controller.Event) {
	fake.nextEventMutex.Lock()
	defer fake.nextEventMutex.Unlock()
	fake.NextEventStub = nil
	fake.nextEventReturns = struct {
		result1 *controller.Event
	}{result1}
}

func (fake *FakeEventHandler) NextEventReturnsOnCall(i int, result1 *controller.Event) {
	fake.nextEventMutex.Lock()
	defer fake.nextEventMutex.Unlock()
	fake.NextEventStub = nil
	if fake.nextEventReturnsOnCall == nil {
		fake.nextEventReturnsOnCall = make(map[int]struct {
			result1 *controller.Event
		})
	}
	fake.nextEventReturnsOnCall[i] = struct {
		result1 *controller.Event
	}{result1}
}

func (fake *FakeEventHandler) ReadEvents() []controller.Event {
	fake.readEventsMutex.Lock()
	ret, specificReturn := fake.readEventsReturnsOnCall[len(fake.readEventsArgsForCall)]
	fake.readEventsArgsForCall = append(fake.readEventsArgsForCall, struct {
	}{})
	stub := fake.ReadEventsStub
	fakeReturns := fake.readEventsReturns
	fake.recordInvocation("ReadEvents", []interface{}{})
	fake.readEventsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeEventHandler) ReadEventsCallCount() int {
	fake.readEventsMutex.RLock()
	defer fake.readEventsMutex.RUnlock()
	return len(fake.readEventsArgsForCall)
}

func (fake *FakeEventHandler) ReadEventsCalls(stub func() []controller.Event) {
	fake.readEventsMutex.Lock()
	defer fake.readEventsMutex.Unlock()
	fake.ReadEventsStub = stub
}

func (fake *FakeEventHandler) ReadEventsReturns(result1 []controller.Event) {
	fake.readEventsMutex.Lock()
	defer fake.readEventsMutex.Unlock()
	fake.ReadEventsStub = nil
	fake.readEventsReturns = struct {
		result1 []controller.Event
	}{result1}
}

func (fake *FakeEventHandler) ReadEventsReturnsOnCall(i int, result1 []controller.Event) {
	fake.readEventsMutex.Lock()
	defer fake.readEventsMutex.Unlock()
	fake.ReadEventsStub = nil
	if fake.readEventsReturnsOnCall == nil {
		fake.readEventsReturnsOnCall = make(map[int]struct {
			result1 []controller.Event
		})
	}
	fake.readEventsReturnsOnCall[i] = struct {
		result1 []controller.Event
	}{result1}
}

func (fake *FakeEventHandler) RemoveEvent(arg1 units.TimeOfDay) error {
	fake.removeEventMutex.Lock()
	ret, specificReturn := fake.removeEventReturnsOnCall[len(fake.removeEventArgsForCall)]
	fake.removeEventArgsForCall = append(fake.removeEventArgsForCall, struct {
		arg1 units.TimeOfDay
	}{arg1})
	stub := fake.RemoveEventStub
	fakeReturns := fake.removeEventReturns
	fake.recordInvocation("RemoveEvent", []interface{}{arg1})
	fake.removeEventMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeEventHandler) RemoveEventCallCount() int {
	fake.removeEventMutex.RLock()
	defer fake.removeEventMutex.RUnlock()
	return len(fake.removeEventArgsForCall)
}

func (fake *FakeEventHandler) RemoveEventCalls(stub func(units.TimeOfDay) error) {
	fake.removeEventMutex.Lock()
	defer fake.removeEventMutex.Unlock()
	fake.RemoveEventStub = stub
}

func (fake *FakeEventHandler) RemoveEventArgsForCall(i int) units.TimeOfDay {
	fake.removeEventMutex.RLock()
	defer fake.removeEventMutex.RUnlock()
	argsForCall := fake.removeEventArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventHandler) RemoveEventReturns(result1 error) {
	fake.removeEventMutex.Lock()
	defer fake.removeEventMutex.Unlock()
	fake.RemoveEventStub = nil
	fake.removeEventReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventHandler) RemoveEventReturnsOnCall(i int, result1 error) {
	fake.removeEventMutex.Lock()
	defer fake.removeEventMutex.Unlock()
	fake.RemoveEventStub = nil
	if fake.removeEventReturnsOnCall == nil {
		fake.removeEventReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeEventReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventHandler) ReplaceEvent(arg1 units.TimeOfDay, arg2 controller.Event) error {
	fake.replaceEventMutex.Lock()
	ret, specificReturn := fake.replaceEventReturnsOnCall[len(fake.replaceEventArgsForCall)]
	fake.replaceEventArgsForCall = append(fake.replaceEventArgsForCall, struct {
		arg1 units.TimeOfDay
		arg2 controller.Event
	}{arg1, arg2})
	stub := fake.ReplaceEventStub
	fakeReturns := fake.replaceEventReturns
	fake.recordInvocation("ReplaceEvent", []interface{}{arg1, arg2})
	fake.replaceEventMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeEventHandler) ReplaceEventCallCount() int {
	fake.replaceEventMutex.RLock()
	defer fake.replaceEventMutex.RUnlock()
	return len(fake.replaceEventArgsForCall)
}

func (fake *FakeEventHandler) ReplaceEventCalls(stub func(units.TimeOfDay, controller.Event) error) {
	fake.replaceEventMutex.Lock()
	defer fake.replaceEventMutex.Unlock()
	fake.ReplaceEventStub = stub
}

func (fake *FakeEventHandler) ReplaceEventArgsForCall(i int) (units.TimeOfDay, controller.Event) {
	fake.replaceEventMutex.RLock()
	defer fake.replaceEventMutex.RUnlock()
	argsForCall := fake.replaceEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeEventHandler) ReplaceEventReturns(result1 error) {
	fake.replaceEventMutex.Lock()
	defer fake.replaceEventMutex.Unlock()
	fake.ReplaceEventStub = nil
	fake.replaceEventReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventHandler) ReplaceEventReturnsOnCall(i int, result1 error) {
	fake.replaceEventMutex.Lock()
	defer fake.replaceEventMutex.Unlock()
	fake.ReplaceEventStub = nil
	if fake.replaceEventReturnsOnCall == nil {
		fake.replaceEventReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.replaceEventReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventHandler) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	fake.boostMutex.RLock()
	defer fake.boostMutex.RUnlock()
	fake.boostedMutex.RLock()
	defer fake.boostedMutex.RUnlock()
	fake.cancelBoostMutex.RLock()
	defer fake.cancelBoostMutex.RUnlock()
	fake.findEventMutex.RLock()
	defer fake.findEventMutex.RUnlock()
	fake.nextEventMutex.RLock()
	defer fake.nextEventMutex.RUnlock()
	fake.readEventsMutex.RLock()
	defer fake.readEventsMutex.RUnlock()
	fake.removeEventMutex.RLock()
	defer fake.removeEventMutex.RUnlock()
	fake.replaceEventMutex.RLock()
	defer fake.replaceEventMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeEventHandler) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ controller.EventHandler = new(FakeEventHandler)
