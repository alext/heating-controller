// Code generated by counterfeiter. DO NOT EDIT.
package schedulerfakes

import (
	"sync"
	"time"

	"github.com/alext/heating-controller/scheduler"
)

type FakeScheduler struct {
	StartStub          func()
	startMutex         sync.RWMutex
	startArgsForCall   []struct{}
	StopStub           func()
	stopMutex          sync.RWMutex
	stopArgsForCall    []struct{}
	RunningStub        func() bool
	runningMutex       sync.RWMutex
	runningArgsForCall []struct{}
	runningReturns     struct {
		result1 bool
	}
	runningReturnsOnCall map[int]struct {
		result1 bool
	}
	AddEventStub        func(scheduler.Event) error
	addEventMutex       sync.RWMutex
	addEventArgsForCall []struct {
		arg1 scheduler.Event
	}
	addEventReturns struct {
		result1 error
	}
	addEventReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveEventStub        func(scheduler.Event)
	removeEventMutex       sync.RWMutex
	removeEventArgsForCall []struct {
		arg1 scheduler.Event
	}
	BoostedStub        func() bool
	boostedMutex       sync.RWMutex
	boostedArgsForCall []struct{}
	boostedReturns     struct {
		result1 bool
	}
	boostedReturnsOnCall map[int]struct {
		result1 bool
	}
	BoostStub        func(time.Duration, func())
	boostMutex       sync.RWMutex
	boostArgsForCall []struct {
		arg1 time.Duration
		arg2 func()
	}
	CancelBoostStub        func()
	cancelBoostMutex       sync.RWMutex
	cancelBoostArgsForCall []struct{}
	NextEventStub          func() *scheduler.Event
	nextEventMutex         sync.RWMutex
	nextEventArgsForCall   []struct{}
	nextEventReturns       struct {
		result1 *scheduler.Event
	}
	nextEventReturnsOnCall map[int]struct {
		result1 *scheduler.Event
	}
	ReadEventsStub        func() []scheduler.Event
	readEventsMutex       sync.RWMutex
	readEventsArgsForCall []struct{}
	readEventsReturns     struct {
		result1 []scheduler.Event
	}
	readEventsReturnsOnCall map[int]struct {
		result1 []scheduler.Event
	}
	OverrideStub        func(scheduler.Event)
	overrideMutex       sync.RWMutex
	overrideArgsForCall []struct {
		arg1 scheduler.Event
	}
	CancelOverrideStub        func()
	cancelOverrideMutex       sync.RWMutex
	cancelOverrideArgsForCall []struct{}
	invocations               map[string][][]interface{}
	invocationsMutex          sync.RWMutex
}

func (fake *FakeScheduler) Start() {
	fake.startMutex.Lock()
	fake.startArgsForCall = append(fake.startArgsForCall, struct{}{})
	fake.recordInvocation("Start", []interface{}{})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		fake.StartStub()
	}
}

func (fake *FakeScheduler) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeScheduler) Stop() {
	fake.stopMutex.Lock()
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct{}{})
	fake.recordInvocation("Stop", []interface{}{})
	fake.stopMutex.Unlock()
	if fake.StopStub != nil {
		fake.StopStub()
	}
}

func (fake *FakeScheduler) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeScheduler) Running() bool {
	fake.runningMutex.Lock()
	ret, specificReturn := fake.runningReturnsOnCall[len(fake.runningArgsForCall)]
	fake.runningArgsForCall = append(fake.runningArgsForCall, struct{}{})
	fake.recordInvocation("Running", []interface{}{})
	fake.runningMutex.Unlock()
	if fake.RunningStub != nil {
		return fake.RunningStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.runningReturns.result1
}

func (fake *FakeScheduler) RunningCallCount() int {
	fake.runningMutex.RLock()
	defer fake.runningMutex.RUnlock()
	return len(fake.runningArgsForCall)
}

func (fake *FakeScheduler) RunningReturns(result1 bool) {
	fake.RunningStub = nil
	fake.runningReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeScheduler) RunningReturnsOnCall(i int, result1 bool) {
	fake.RunningStub = nil
	if fake.runningReturnsOnCall == nil {
		fake.runningReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.runningReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeScheduler) AddEvent(arg1 scheduler.Event) error {
	fake.addEventMutex.Lock()
	ret, specificReturn := fake.addEventReturnsOnCall[len(fake.addEventArgsForCall)]
	fake.addEventArgsForCall = append(fake.addEventArgsForCall, struct {
		arg1 scheduler.Event
	}{arg1})
	fake.recordInvocation("AddEvent", []interface{}{arg1})
	fake.addEventMutex.Unlock()
	if fake.AddEventStub != nil {
		return fake.AddEventStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addEventReturns.result1
}

func (fake *FakeScheduler) AddEventCallCount() int {
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	return len(fake.addEventArgsForCall)
}

func (fake *FakeScheduler) AddEventArgsForCall(i int) scheduler.Event {
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	return fake.addEventArgsForCall[i].arg1
}

func (fake *FakeScheduler) AddEventReturns(result1 error) {
	fake.AddEventStub = nil
	fake.addEventReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeScheduler) AddEventReturnsOnCall(i int, result1 error) {
	fake.AddEventStub = nil
	if fake.addEventReturnsOnCall == nil {
		fake.addEventReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addEventReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeScheduler) RemoveEvent(arg1 scheduler.Event) {
	fake.removeEventMutex.Lock()
	fake.removeEventArgsForCall = append(fake.removeEventArgsForCall, struct {
		arg1 scheduler.Event
	}{arg1})
	fake.recordInvocation("RemoveEvent", []interface{}{arg1})
	fake.removeEventMutex.Unlock()
	if fake.RemoveEventStub != nil {
		fake.RemoveEventStub(arg1)
	}
}

func (fake *FakeScheduler) RemoveEventCallCount() int {
	fake.removeEventMutex.RLock()
	defer fake.removeEventMutex.RUnlock()
	return len(fake.removeEventArgsForCall)
}

func (fake *FakeScheduler) RemoveEventArgsForCall(i int) scheduler.Event {
	fake.removeEventMutex.RLock()
	defer fake.removeEventMutex.RUnlock()
	return fake.removeEventArgsForCall[i].arg1
}

func (fake *FakeScheduler) Boosted() bool {
	fake.boostedMutex.Lock()
	ret, specificReturn := fake.boostedReturnsOnCall[len(fake.boostedArgsForCall)]
	fake.boostedArgsForCall = append(fake.boostedArgsForCall, struct{}{})
	fake.recordInvocation("Boosted", []interface{}{})
	fake.boostedMutex.Unlock()
	if fake.BoostedStub != nil {
		return fake.BoostedStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.boostedReturns.result1
}

func (fake *FakeScheduler) BoostedCallCount() int {
	fake.boostedMutex.RLock()
	defer fake.boostedMutex.RUnlock()
	return len(fake.boostedArgsForCall)
}

func (fake *FakeScheduler) BoostedReturns(result1 bool) {
	fake.BoostedStub = nil
	fake.boostedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeScheduler) BoostedReturnsOnCall(i int, result1 bool) {
	fake.BoostedStub = nil
	if fake.boostedReturnsOnCall == nil {
		fake.boostedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.boostedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeScheduler) Boost(arg1 time.Duration, arg2 func()) {
	fake.boostMutex.Lock()
	fake.boostArgsForCall = append(fake.boostArgsForCall, struct {
		arg1 time.Duration
		arg2 func()
	}{arg1, arg2})
	fake.recordInvocation("Boost", []interface{}{arg1, arg2})
	fake.boostMutex.Unlock()
	if fake.BoostStub != nil {
		fake.BoostStub(arg1, arg2)
	}
}

func (fake *FakeScheduler) BoostCallCount() int {
	fake.boostMutex.RLock()
	defer fake.boostMutex.RUnlock()
	return len(fake.boostArgsForCall)
}

func (fake *FakeScheduler) BoostArgsForCall(i int) (time.Duration, func()) {
	fake.boostMutex.RLock()
	defer fake.boostMutex.RUnlock()
	return fake.boostArgsForCall[i].arg1, fake.boostArgsForCall[i].arg2
}

func (fake *FakeScheduler) CancelBoost() {
	fake.cancelBoostMutex.Lock()
	fake.cancelBoostArgsForCall = append(fake.cancelBoostArgsForCall, struct{}{})
	fake.recordInvocation("CancelBoost", []interface{}{})
	fake.cancelBoostMutex.Unlock()
	if fake.CancelBoostStub != nil {
		fake.CancelBoostStub()
	}
}

func (fake *FakeScheduler) CancelBoostCallCount() int {
	fake.cancelBoostMutex.RLock()
	defer fake.cancelBoostMutex.RUnlock()
	return len(fake.cancelBoostArgsForCall)
}

func (fake *FakeScheduler) NextEvent() *scheduler.Event {
	fake.nextEventMutex.Lock()
	ret, specificReturn := fake.nextEventReturnsOnCall[len(fake.nextEventArgsForCall)]
	fake.nextEventArgsForCall = append(fake.nextEventArgsForCall, struct{}{})
	fake.recordInvocation("NextEvent", []interface{}{})
	fake.nextEventMutex.Unlock()
	if fake.NextEventStub != nil {
		return fake.NextEventStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nextEventReturns.result1
}

func (fake *FakeScheduler) NextEventCallCount() int {
	fake.nextEventMutex.RLock()
	defer fake.nextEventMutex.RUnlock()
	return len(fake.nextEventArgsForCall)
}

func (fake *FakeScheduler) NextEventReturns(result1 *scheduler.Event) {
	fake.NextEventStub = nil
	fake.nextEventReturns = struct {
		result1 *scheduler.Event
	}{result1}
}

func (fake *FakeScheduler) NextEventReturnsOnCall(i int, result1 *scheduler.Event) {
	fake.NextEventStub = nil
	if fake.nextEventReturnsOnCall == nil {
		fake.nextEventReturnsOnCall = make(map[int]struct {
			result1 *scheduler.Event
		})
	}
	fake.nextEventReturnsOnCall[i] = struct {
		result1 *scheduler.Event
	}{result1}
}

func (fake *FakeScheduler) ReadEvents() []scheduler.Event {
	fake.readEventsMutex.Lock()
	ret, specificReturn := fake.readEventsReturnsOnCall[len(fake.readEventsArgsForCall)]
	fake.readEventsArgsForCall = append(fake.readEventsArgsForCall, struct{}{})
	fake.recordInvocation("ReadEvents", []interface{}{})
	fake.readEventsMutex.Unlock()
	if fake.ReadEventsStub != nil {
		return fake.ReadEventsStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.readEventsReturns.result1
}

func (fake *FakeScheduler) ReadEventsCallCount() int {
	fake.readEventsMutex.RLock()
	defer fake.readEventsMutex.RUnlock()
	return len(fake.readEventsArgsForCall)
}

func (fake *FakeScheduler) ReadEventsReturns(result1 []scheduler.Event) {
	fake.ReadEventsStub = nil
	fake.readEventsReturns = struct {
		result1 []scheduler.Event
	}{result1}
}

func (fake *FakeScheduler) ReadEventsReturnsOnCall(i int, result1 []scheduler.Event) {
	fake.ReadEventsStub = nil
	if fake.readEventsReturnsOnCall == nil {
		fake.readEventsReturnsOnCall = make(map[int]struct {
			result1 []scheduler.Event
		})
	}
	fake.readEventsReturnsOnCall[i] = struct {
		result1 []scheduler.Event
	}{result1}
}

func (fake *FakeScheduler) Override(arg1 scheduler.Event) {
	fake.overrideMutex.Lock()
	fake.overrideArgsForCall = append(fake.overrideArgsForCall, struct {
		arg1 scheduler.Event
	}{arg1})
	fake.recordInvocation("Override", []interface{}{arg1})
	fake.overrideMutex.Unlock()
	if fake.OverrideStub != nil {
		fake.OverrideStub(arg1)
	}
}

func (fake *FakeScheduler) OverrideCallCount() int {
	fake.overrideMutex.RLock()
	defer fake.overrideMutex.RUnlock()
	return len(fake.overrideArgsForCall)
}

func (fake *FakeScheduler) OverrideArgsForCall(i int) scheduler.Event {
	fake.overrideMutex.RLock()
	defer fake.overrideMutex.RUnlock()
	return fake.overrideArgsForCall[i].arg1
}

func (fake *FakeScheduler) CancelOverride() {
	fake.cancelOverrideMutex.Lock()
	fake.cancelOverrideArgsForCall = append(fake.cancelOverrideArgsForCall, struct{}{})
	fake.recordInvocation("CancelOverride", []interface{}{})
	fake.cancelOverrideMutex.Unlock()
	if fake.CancelOverrideStub != nil {
		fake.CancelOverrideStub()
	}
}

func (fake *FakeScheduler) CancelOverrideCallCount() int {
	fake.cancelOverrideMutex.RLock()
	defer fake.cancelOverrideMutex.RUnlock()
	return len(fake.cancelOverrideArgsForCall)
}

func (fake *FakeScheduler) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	fake.runningMutex.RLock()
	defer fake.runningMutex.RUnlock()
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	fake.removeEventMutex.RLock()
	defer fake.removeEventMutex.RUnlock()
	fake.boostedMutex.RLock()
	defer fake.boostedMutex.RUnlock()
	fake.boostMutex.RLock()
	defer fake.boostMutex.RUnlock()
	fake.cancelBoostMutex.RLock()
	defer fake.cancelBoostMutex.RUnlock()
	fake.nextEventMutex.RLock()
	defer fake.nextEventMutex.RUnlock()
	fake.readEventsMutex.RLock()
	defer fake.readEventsMutex.RUnlock()
	fake.overrideMutex.RLock()
	defer fake.overrideMutex.RUnlock()
	fake.cancelOverrideMutex.RLock()
	defer fake.cancelOverrideMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeScheduler) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ scheduler.Scheduler = new(FakeScheduler)
